// Copyright 2024 Itential Inc. All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited
// Proprietary and confidential

package runners

import (
	"os"
	"path/filepath"

	"github.com/itential/ipctl/internal/flags"
	"github.com/itential/ipctl/internal/utils"
	"github.com/itential/ipctl/pkg/config"
	"github.com/itential/ipctl/pkg/logger"
)

const (
	defaultCommitMessage = "autogenerated commit message from ipctl"
)

type PushAction struct {
	Name     string
	Filename string
	Data     any
	Config   *config.Config
	Options  flags.AssetPushCommon
}

func (p PushAction) Clone() (string, error) {
	logger.Trace()

	repo, err := GetRepository(p.Name, p.Config)
	if err != nil {
		return "", err
	}

	if p.Options.Reference != "" {
		repo.Reference = p.Options.Reference
	}

	return CloneRepository(repo)
}

func (p PushAction) Do() error {
	logger.Trace()

	repoPath, err := p.Clone()
	if err != nil {
		return err
	}
	defer os.Remove(repoPath)

	path := filepath.Join(repoPath, p.Options.Path)

	if err := utils.EnsurePathExists(path); err != nil {
		return err
	}

	if err := utils.WriteJsonToDisk(p.Data, p.Filename, path); err != nil {
		return err
	}

	if err := p.Commit(repoPath); err != nil {
		return err
	}

	return nil
}

func (p PushAction) Commit(path string) error {
	logger.Trace()

	repo, err := GetRepository(p.Name, p.Config)
	if err != nil {
		return err
	}

	msg := p.Options.Message
	if msg == "" {
		msg = defaultCommitMessage
	}

	if err := CommitAndPushRepo(repo, path, msg); err != nil {
		return err
	}

	return nil
}

type PullAction struct {
	Name     string
	Filename string
	Data     any
	Config   *config.Config
	Options  flags.AssetPullCommon
}

func (p PullAction) Clone() (string, error) {
	logger.Trace()

	repo, err := GetRepository(p.Name, p.Config)
	if err != nil {
		return "", err
	}

	if p.Options.Reference != "" {
		repo.Reference = p.Options.Reference
	}

	return CloneRepository(repo)
}

func (p PullAction) Do() ([]byte, error) {
	logger.Trace()

	path, err := p.Clone()
	if err != nil {
		return nil, err
	}
	defer os.Remove(path)

	path = filepath.Join(path, p.Options.Path, p.Filename)
	logger.Info(path)

	return utils.ReadFromFile(path)
}
